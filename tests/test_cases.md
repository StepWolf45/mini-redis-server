# Тест-кейсы и покрытие тестами

## 1. Обзор функциональности
- **Протокол**: расширенный inline-ввод команд с поддержкой кавычек и экранирования, ответы в стиле RESP. Полная поддержка RESP-протокола (массивы, bulk strings, integers, errors) с защитой от больших сообщений (лимиты на размер команд, массивов и bulk strings).
- **Команды**: GET, SET (+EX/PX для TTL), TTL, EXPIRE, EXISTS, DEL, KEYS. Поддержка Redis-совместимых команд с валидацией аргументов.
- **Хранилище**: оптимизированное in-memory хранилище с TTL, эффективная фоновая очистка через heap , ленивая очистка при обращениях. 
- **Расширяемость**: автоматическая регистрация команд через декораторы @register_command, фабрика команд для управления зависимостями.


### 2. Тест-кейсы

## 2.1 Storage (tests/unit/test_storage.py)

#### Тест-кейс 1: Проверка установки и получения значения ключа без TTL

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод set с ключом "key1" и значением "value1" без TTL
2. Вызвать метод get с ключом "key1"

**Ожидаемый результат:**
1. Метод set возвращает True
2. Метод get возвращает (True, "value1")

**Постусловие:** Нет

#### Тест-кейс 2: Проверка получения значения для несуществующего ключа

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод get с ключом "absent"

**Ожидаемый результат:**
1. Метод get возвращает (False, None)

**Постусловие:** Нет

#### Тест-кейс 3: Проверка установки значения с TTL и автоматического истечения

**Предусловие:** Создан экземпляр Storage, запущена фоновая очистка

**Шаги проверки:**
1. Вызвать метод set с ключом "temp", значением "v" и TTL 0.2 секунды
2. Немедленно вызвать метод get с ключом "temp"
3. Подождать 0.35 секунды
4. Вызвать метод get с ключом "temp"

**Ожидаемый результат:**
1. Метод set возвращает True
2. Метод get возвращает (True, "v")
3. После ожидания метод get возвращает (False, None)

**Постусловие:** Остановить фоновую очистку

#### Тест-кейс 4: Проверка установки TTL для существующего ключа через EXPIRE

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод set с ключом "key" и значением "value"
2. Вызвать метод expire с ключом "key" и TTL 0.1 секунды
3. Проверить TTL через метод ttl
4. Подождать 0.15 секунды
5. Вызвать метод get с ключом "key"

**Ожидаемый результат:**
1. Метод set возвращает True
2. Метод expire возвращает True
3. Метод ttl возвращает значение >= 0
4. После ожидания метод get возвращает (False, None)

**Постусловие:** Нет

#### Тест-кейс 5: Проверка возврата TTL для отсутствующего, бессрочного и ключей с TTL

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод ttl с ключом "nonexistent"
2. Вызвать метод set с ключом "permanent" и значением "v" без TTL
3. Вызвать метод ttl с ключом "permanent"
4. Вызвать метод set с ключом "temp" и значением "v" с TTL 1 секунда
5. Вызвать метод ttl с ключом "temp"

**Ожидаемый результат:**
1. Метод ttl возвращает -2
2. Метод set возвращает True
3. Метод ttl возвращает -1
4. Метод set возвращает True
5. Метод ttl возвращает значение в диапазоне 0..1

**Постусловие:** Нет

#### Тест-кейс 6: Проверка методов exists и delete

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод set с ключом "key1" и значением "value1"
2. Вызвать метод exists с ключом "key1"
3. Вызвать метод delete с ключом "key1"
4. Вызвать метод exists с ключом "key1"
5. Вызвать метод delete с ключом "key1"

**Ожидаемый результат:**
1. Метод set возвращает True
2. Метод exists возвращает True
3. Метод delete возвращает True
4. Метод exists возвращает False
5. Метод delete возвращает False

**Постусловие:** Нет

#### Тест-кейс 7: Проверка методов keys и size с автоматической очисткой истекших ключей

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод set с ключом "k1" и значением "v1" без TTL
2. Вызвать метод set с ключом "k2" и значением "v2" с TTL 0.1 секунды
3. Вызвать метод set с ключом "other" и значением "v3" без TTL
4. Вызвать метод keys с паттерном "*"
5. Подождать 0.15 секунды
6. Вызвать метод size
7. Вызвать метод keys с паттерном "*"

**Ожидаемый результат:**
1. Метод set возвращает True для каждого
2. Метод keys возвращает список из 3 ключей включая "k2"
3. Метод size возвращает 2
4. Метод keys возвращает список из 2 ключей без "k2"

**Постусловие:** Нет

#### Тест-кейс 8: Проверка эффективности фоновой очистки с использованием heap

**Предусловие:** Создан экземпляр Storage, запущена фоновая очистка

**Шаги проверки:**
1. Вызвать метод set с различными ключами и TTL (short: 0.1s, medium: 0.3s, long: 1.0s, permanent: без TTL)
2. Проверить существование всех ключей
3. Подождать 0.15 секунды
4. Проверить существование ключей (short истек, остальные нет)
5. Подождать еще 0.2 секунды
6. Проверить существование ключей (medium истек, остальные нет)

**Ожидаемый результат:**
1. Все методы set возвращают True
2. Все ключи существуют
3. Только short ключ истек
4. Только medium ключ истек, long и permanent существуют

**Постусловие:** Остановить фоновую очистку

#### Тест-кейс 9: Проверка корректного обновления TTL в heap

**Предусловие:** Создан экземпляр Storage, запущена фоновая очистка

**Шаги проверки:**
1. Вызвать метод set с ключом "key", значением "value" и TTL 0.1 секунды
2. Вызвать метод expire с ключом "key" и новым TTL 1.0 секунды
3. Подождать 0.2 секунды
4. Вызвать метод exists с ключом "key"

**Ожидаемый результат:**
1. Метод set возвращает True
2. Метод expire возвращает True
3. Метод exists возвращает True (ключ не истек)

**Постусловие:** Остановить фоновую очистку

#### Тест-кейс 10: Проверка метода clear для сброса данных и heap

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод set с ключом "k1" и значением "v1" с TTL
2. Вызвать метод set с ключом "k2" и значением "v2" без TTL
3. Вызвать метод clear
4. Проверить размер хранилища
5. Проверить размер heap

**Ожидаемый результат:**
1. Методы set возвращают True
2. Метод clear выполняется без ошибок
3. Размер хранилища равен 0
4. Размер heap равен 0

**Постусловие:** Нет

#### Тест-кейс 11: Проверка метода _match_pattern для различных паттернов

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Вызвать метод _match_pattern с ключом "key1" и паттерном "*"
2. Вызвать метод _match_pattern с ключом "key1" и паттерном "key1"
3. Вызвать метод _match_pattern с ключом "key1" и паттерном "key?"
4. Вызвать метод _match_pattern с ключом "key1" и паттерном "key2"
5. Вызвать метод _match_pattern с ключом "key1" и паттерном "k*"
6. Вызвать метод _match_pattern с ключом "key1" и паттерном "*1"

**Ожидаемый результат:**
1. Возвращает True
2. Возвращает True
3. Возвращает True
4. Возвращает False
5. Возвращает True
6. Возвращает True

**Постусловие:** Нет

#### Тест-кейс 12: Проверка обработки исключений в ttl для истекших ключей

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Установить значение с TTL 0.1 секунды
2. Подождать 0.15 секунды
3. Вызвать метод ttl для истекшего ключа

**Ожидаемый результат:**
1. Значение установлено
2. Время прошло
3. Метод ttl возвращает -2

**Постусловие:** Нет

#### Тест-кейс 13: Проверка обработки исключений в expire для истекших ключей

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Установить значение с TTL 0.1 секунды
2. Подождать 0.15 секунды
3. Вызвать метод expire для истекшего ключа

**Ожидаемый результат:**
1. Значение установлено
2. Время прошло
3. Метод expire возвращает False

**Постусловие:** Нет

#### Тест-кейс 14: Проверка метода keys с паттерном

**Предусловие:** Создан экземпляр Storage

**Шаги проверки:**
1. Установить значения для ключей "user1", "user2", "admin"
2. Вызвать метод keys с паттерном "user*"

**Ожидаемый результат:**
1. Значения установлены
2. Возвращает список ["user1", "user2"]

**Постусловие:** Нет

### 2.2 Command base (tests/unit/test_command_base.py)

#### Тест-кейс 12: Проверка валидации количества аргументов в методе validate_args

**Предусловие:** Импортирован класс Command

**Шаги проверки:**
1. Вызвать метод validate_args с args=[], min_args=1, max_args=None
2. Вызвать метод validate_args с args=["a"], min_args=1, max_args=None
3. Вызвать метод validate_args с args=["a", "b"], min_args=1, max_args=1
4. Вызвать метод validate_args с args=["a"], min_args=1, max_args=2

**Ожидаемый результат:**
1. Возвращает False (недостаточно аргументов)
2. Возвращает True
3. Возвращает False (слишком много аргументов)
4. Возвращает True

**Постусловие:** Нет

### 2.3 Parser (tests/unit/test_command_parser.py)

#### Тест-кейс 13: Проверка разбора командной строки методом parse_command

**Предусловие:** Импортирован класс CommandParser

**Шаги проверки:**
1. Вызвать метод parse_command с строкой "SET a 1"
2. Вызвать метод parse_command с строкой "  GET   a  "
3. Вызвать метод parse_command с пустой строкой ""

**Ожидаемый результат:**
1. Возвращает ["SET", "a", "1"]
2. Возвращает ["GET", "a"]
3. Возвращает []

**Постусловие:** Нет

#### Тест-кейс 14: Проверка форматирования скалярных значений методом format_response

**Предусловие:** Импортирован класс CommandParser

**Шаги проверки:**
1. Вызвать метод format_response с None
2. Вызвать метод format_response с целым числом 5
3. Вызвать метод format_response с булевым True
4. Вызвать метод format_response с булевым False
5. Вызвать метод format_response со строкой "ok"
6. Вызвать метод format_response с float 3.14
7. Вызвать методом format_response со словарем {"key": "value"}

**Ожидаемый результат:**
1. Возвращает "$-1\r\n"
2. Возвращает ":5\r\n"
3. Возвращает ":1\r\n"
4. Возвращает ":0\r\n"
5. Возвращает "$2\r\nok\r\n"
6. Возвращает "$4\r\n3.14\r\n"
7. Возвращает строку формата "$N\r\n{'key': 'value'}\r\n" где N - длина строки

**Постусловие:** Нет

#### Тест-кейс 15: Проверка форматирования списков методом format_response

**Предусловие:** Импортирован класс CommandParser

**Шаги проверки:**
1. Вызвать метод format_response со списком ["a", 2, None]

**Ожидаемый результат:**
1. Возвращает строку, начинающуюся с "*3\r\n", содержащую отформатированные элементы

**Постусловие:** Нет

#### Тест-кейс 16: Проверка методов format_error и format_ok

**Предусловие:** Импортирован класс CommandParser

**Шаги проверки:**
1. Вызвать метод format_error с сообщением "ERR"
2. Вызвать метод format_ok

**Ожидаемый результат:**
1. Возвращает "-ERR\r\n"
2. Возвращает "+OK\r\n"

**Постусловие:** Нет

#### Тест-кейс 18: Проверка парсинга inline-команд с кавычками

**Предусловие:** Импортирован класс CommandParser

**Шаги проверки:**
1. Вызвать метод parse_command с "SET key \"hello world\""
2. Вызвать метод parse_command с "SET key 'single quotes'"
3. Вызвать метод parse_command с "SET key value"
4. Вызвать метод parse_command с пустой строкой

**Ожидаемый результат:**
1. Возвращает ["SET", "key", "hello world"]
2. Возвращает ["SET", "key", "single quotes"]
3. Возвращает ["SET", "key", "value"]
4. Возвращает []

**Постусловие:** Нет

### 2.4 Команды GET/SET (tests/unit/test_commands.py)

#### Тест-кейс 17: Проверка команды SET для установки значения без TTL

**Предусловие:** Создан экземпляр Storage, создан экземпляр SetCommand

**Шаги проверки:**
1. Вызвать метод execute команды SetCommand с аргументами ["key", "value"]

**Ожидаемый результат:**
1. Возвращает (True, "OK"), значение записано в хранилище

**Постусловие:** Нет

#### Тест-кейс 18: Проверка команды SET с опцией EX для установки TTL в секундах

**Предусловие:** Создан экземпляр Storage, создан экземпляр SetCommand

**Шаги проверки:**
1. Вызвать метод execute команды SetCommand с аргументами ["key", "value", "EX", "1"]
2. Проверить TTL ключа через storage.ttl

**Ожидаемый результат:**
1. Возвращает (True, "OK"), значение записано с TTL
2. TTL возвращает значение около 1 секунды

**Постусловие:** Нет

#### Тест-кейс 19: Проверка команды SET с опцией PX для установки TTL в миллисекундах

**Предусловие:** Создан экземпляр Storage, создан экземпляр SetCommand

**Шаги проверки:**
1. Вызвать метод execute команды SetCommand с аргументами ["key", "value", "PX", "1000"]
2. Проверить TTL ключа через storage.ttl

**Ожидаемый результат:**
1. Возвращает (True, "OK"), значение записано с TTL
2. TTL возвращает значение около 1 секунды

**Постусловие:** Нет

#### Тест-кейс 20: Проверка валидации аргументов команды SET

**Предусловие:** Создан экземпляр Storage, создан экземпляр SetCommand

**Шаги проверки:**
1. Вызвать метод execute с недостаточным количеством аргументов ["key"]
2. Вызвать метод execute с неверным значением EX ["key", "value", "EX", "invalid"]
3. Вызвать метод execute с отрицательным EX ["key", "value", "EX", "-1"]
4. Вызвать метод execute с неизвестной опцией ["key", "value", "UNKNOWN", "1"]

**Ожидаемый результат:**
1. Возвращает (False, сообщение об ошибке)
2. Возвращает (False, сообщение об ошибке)
3. Возвращает (False, сообщение об ошибке)
4. Возвращает (False, сообщение об ошибке)

**Постусловие:** Нет

#### Тест-кейс 21: Проверка команды GET для существующего и несуществующего ключа

**Предусловие:** Создан экземпляр Storage, создан экземпляр GetCommand

**Шаги проверки:**
1. Вызвать метод execute команды GetCommand с аргументом ["nonexistent"]
2. Установить значение через storage.set("key", "value")
3. Вызвать метод execute команды GetCommand с аргументом ["key"]

**Ожидаемый результат:**
1. Возвращает (True, None)
2. Значение установлено
3. Возвращает (True, "value")

**Постусловие:** Нет

#### Тест-кейс 22: Проверка интеграции команд SET и GET

**Предусловие:** Создан экземпляр Storage, созданы экземпляры SetCommand и GetCommand

**Шаги проверки:**
1. Вызвать метод execute команды SetCommand с аргументами ["test", "hello"]
2. Вызвать метод execute команды GetCommand с аргументом ["test"]
3. Вызвать метод execute команды SetCommand с аргументами ["test", "world"]
4. Вызвать метод execute команды GetCommand с аргументом ["test"]

**Ожидаемый результат:**
1. Возвращает (True, "OK")
2. Возвращает (True, "hello")
3. Возвращает (True, "OK")
4. Возвращает (True, "world")

**Постусловие:** Нет

#### Тест-кейс 23: Проверка обработки ошибки в хранилище при выполнении SET

**Предусловие:** Создан mock Storage с методом set, возвращающим False, создан экземпляр SetCommand

**Шаги проверки:**
1. Вызвать метод execute команды SetCommand с аргументами ["key", "value"]

**Ожидаемый результат:**
1. Возвращает (False, "ERR: failed to set value")

**Постусловие:** Нет

### 2.5 TTL/EXPIRE/EXISTS/DEL/KEYS (tests/unit/test_ttl_commands.py)

#### Тест-кейс 24: Проверка команды TTL для отсутствующего, бессрочного и ключей с TTL

**Предусловие:** Создан экземпляр Storage, создан экземпляр TtlCommand

**Шаги проверки:**
1. Вызвать метод execute с аргументом ["nonexistent"]
2. Установить значение без TTL через storage.set("permanent", "value")
3. Вызвать метод execute с аргументом ["permanent"]
4. Установить значение с TTL через storage.set("temp", "value", ttl=1.0)
5. Вызвать метод execute с аргументом ["temp"]

**Ожидаемый результат:**
1. Возвращает (True, -2)
2. Значение установлено
3. Возвращает (True, -1)
4. Значение установлено
5. Возвращает (True, значение в диапазоне 0..1)

**Постусловие:** Нет

#### Тест-кейс 25: Проверка команды EXPIRE для установки TTL существующего ключа

**Предусловие:** Создан экземпляр Storage, создан экземпляр ExpireCommand

**Шаги проверки:**
1. Установить значение через storage.set("key", "value")
2. Вызвать метод execute с аргументами ["key", "1"]
3. Проверить TTL через storage.ttl("key")
4. Подождать 1.5 секунды
5. Проверить существование ключа через storage.exists("key")

**Ожидаемый результат:**
1. Значение установлено
2. Возвращает (True, 1)
3. TTL около 1 секунды
4. Ключ истек и не существует

**Постусловие:** Нет

#### Тест-кейс 26: Проверка команды EXISTS для проверки существования ключей

**Предусловие:** Создан экземпляр Storage, создан экземпляр ExistsCommand

**Шаги проверки:**
1. Установить значения для ключей "key1", "key2"
2. Вызвать метод execute с аргументом ["key1"]
3. Вызвать метод execute с аргументами ["key1", "key2", "nonexistent"]

**Ожидаемый результат:**
1. Значения установлены
2. Возвращает (True, 1)
3. Возвращает (True, 2)

**Постусловие:** Нет

#### Тест-кейс 27: Проверка команды DEL для удаления ключей

**Предусловие:** Создан экземпляр Storage, создан экземпляр DelCommand

**Шаги проверки:**
1. Установить значения для ключей "key1", "key2"
2. Вызвать метод execute с аргументом ["key1"]
3. Вызвать метод execute с аргументами ["key2", "nonexistent"]

**Ожидаемый результат:**
1. Значения установлены
2. Возвращает (True, 1), ключ удален
3. Возвращает (True, 1), ключ удален

**Постусловие:** Нет

#### Тест-кейс 28: Проверка команды KEYS для получения списка ключей

**Предусловие:** Создан экземпляр Storage, создан экземпляр KeysCommand

**Шаги проверки:**
1. Установить значения для ключей "user:1", "user:2", "session:abc"
2. Вызвать метод execute с аргументом ["*"]

**Ожидаемый результат:**
1. Значения установлены
2. Возвращает (True, список из 3 ключей)

**Постусловие:** Нет

#### Тест-кейс 29: Проверка полного workflow команд с TTL

**Предусловие:** Создан экземпляр Storage, созданы экземпляры всех команд

**Шаги проверки:**
1. Установить значение через SetCommand с TTL
2. Проверить TTL через TtlCommand
3. Проверить существование через ExistsCommand
4. Изменить TTL через ExpireCommand
5. Подождать истечения
6. Проверить отсутствие ключа через ExistsCommand

**Ожидаемый результат:**
1. Значение установлено с TTL
2. TTL корректный
3. Ключ существует
4. TTL изменен
5. Время прошло
6. Ключ истек

**Постусловие:** Нет

#### Тест-кейс 30: Проверка команды KEYS с glob-шаблонами

**Предусловие:** Создан экземпляр Storage, создан экземпляр KeysCommand

**Шаги проверки:**
1. Установить значения для ключей "user:1", "user:2", "user:10", "session:abc", "session:def"
2. Выполнить KEYS "user:*"
3. Выполнить KEYS "user:?"
4. Выполнить KEYS "user:[12]"
5. Выполнить KEYS "session:*"

**Ожидаемый результат:**
1. Ключи установлены
2. Возвращает ["user:1", "user:2", "user:10"]
3. Возвращает ["user:1", "user:2"]
4. Возвращает ["user:1", "user:2"]
5. Возвращает ["session:abc", "session:def"]

**Постусловие:** Нет

### 2.6 Command Handler (tests/unit/test_command_handler.py)

#### Тест-кейс 30: Проверка автоматической регистрации команд с декоратором @register_command

**Предусловие:** Импортированы декораторы и CommandHandler

**Шаги проверки:**
1. Определить тестовую команду с декоратором @register_command("TEST_CMD")
2. Создать экземпляр CommandHandler
3. Проверить наличие команды в списке доступных

**Ожидаемый результат:**
1. Команда определена
2. CommandHandler создан
3. Команда "TEST_CMD" доступна

**Постусловие:** Нет

#### Тест-кейс 31: Проверка фабрики команд для создания экземпляров с зависимостями

**Предусловие:** Импортирована фабрика команд

**Шаги проверки:**
1. Создать фабрику команд с Storage
2. Создать команду через фабрику
3. Проверить тип созданного объекта

**Ожидаемый результат:**
1. Фабрика создана
2. Команда создана
3. Объект является экземпляром правильного класса команды

**Постусловие:** Нет

#### Тест-кейс 32: Проверка выполнения команд через CommandHandler

**Предусловие:** Создан экземпляр CommandHandler

**Шаги проверки:**
1. Вызвать метод handle с известной командой "SET" и аргументами
2. Вызвать метод handle с неизвестной командой "UNKNOWN"

**Ожидаемый результат:**
1. Возвращает результат выполнения команды
2. Возвращает (False, сообщение об ошибке)

**Постусловие:** Нет

#### Тест-кейс 33: Проверка обработки исключений при выполнении команд

**Предусловие:** Создан экземпляр CommandHandler

**Шаги проверки:**
1. Зарегистрировать команду, которая вызывает исключение
2. Вызвать метод handle с этой командой

**Ожидаемый результат:**
1. Команда зарегистрирована
2. Возвращает (False, сообщение об ошибке с исключением)

**Постусловие:** Нет

#### Тест-кейс 34: Проверка интеграции CommandHandler с существующими командами

**Предусловие:** Создан экземпляр CommandHandler

**Шаги проверки:**
1. Выполнить последовательность команд через handle: SET, GET, TTL, EXPIRE
2. Проверить корректность результатов

**Ожидаемый результат:**
1. Все команды выполняются корректно
2. Результаты соответствуют ожидаемым

**Постусловие:** Нет

#### Тест-кейс 35: Проверка обработки исключений в handle с mock командой

**Предусловие:** Создан экземпляр CommandHandler

**Шаги проверки:**
1. Зарегистрировать mock команду, которая вызывает исключение
2. Вызвать метод handle с этой командой

**Ожидаемый результат:**
1. Команда зарегистрирована
2. Возвращает (False, "ERR: Mock error")

**Постусловие:** Нет

#### Тест-кейс 36: Проверка обработки исключений в командах с декоратором

**Предусловие:** Создан экземпляр CommandHandler

**Шаги проверки:**
1. Определить команду с декоратором @register_command, которая вызывает ValueError
2. Вызвать метод handle с этой командой

**Ожидаемый результат:**
1. Команда определена и зарегистрирована
2. Возвращает (False, "ERR: Test error")

**Постусловие:** Нет

## 3. Интеграционные тесты (tests/integration/test_tcp_server.py)

#### Тест-кейс 35: Проверка базового end-to-end сценария SET/GET/TTL через TCP соединение

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить команду "SET key value"
3. Прочитать ответ сервера
4. Отправить команду "GET key"
5. Прочитать ответ сервера
6. Отправить команду "SET key2 value EX 1"
7. Отправить команду "TTL key2"
8. Прочитать ответ сервера
9. Подождать 1.1 секунды
10. Отправить команду "GET key2"
11. Прочитать ответ сервера

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ "+OK\r\n"
3. Ответ "$5\r\nvalue\r\n"
4. Ответ "+OK\r\n"
5. Ответ ":1\r\n" (TTL около 1 секунды)
6. После ожидания ответ "$-1\r\n" (ключ истек)

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 36: Проверка обработки неизвестной команды через TCP

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить неизвестную команду "PING"
3. Прочитать ответ сервера

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR: unknown command"

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 37: Проверка обработки таймаутов при чтении команд

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить неполную команду без завершения
3. Подождать больше 3 секунд
4. Попытаться прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Команда отправлена
3. После таймаута ответ содержит ошибку или соединение закрыто

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 38: Проверка обработки некорректных RESP данных

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить malformed RESP данные (например, некорректный массив)
3. Прочитать ответ сервера

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с описанием ошибки протокола

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 39: Проверка обработки исключений в методах start/stop сервера

**Предусловие:** Создан экземпляр TCPServer

**Шаги проверки:**
1. Замокать методы storage.start_cleanup_task и stop_cleanup_task для вызова исключений
2. Вызвать метод start сервера
3. Вызвать метод stop сервера

**Ожидаемый результат:**
1. Методы замоканы
2. Start выполняется без падения несмотря на исключение
3. Stop выполняется без падения несмотря на исключение

**Постусловие:** Нет

#### Тест-кейс 40: Проверка RESP пайплайна и KEYS с шаблонами через TCP

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить RESP пайплайн с двумя SET и одним GET
3. Прочитать ответы
4. Отправить KEYS с шаблоном "user*"
5. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответы на SET: +OK, на GET: значение
3. Ответ содержит массив с user1, user2

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 41: Проверка обработки malformed RESP данных

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить malformed RESP данные (*invalid)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с ошибкой протокола

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 42: Проверка неполного RESP массива

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить неполный RESP массив (*2 SET без второго элемента)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с ошибкой протокола

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 43: Проверка некорректной длины RESP массива

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить массив с некорректной длиной (*invalid)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с ошибкой протокола

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 44: Проверка некорректного bulk string в RESP массиве

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить массив с некорректным bulk string (+notbulk вместо $)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с ожиданием bulk string

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 45: Проверка некорректной длины bulk string

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить bulk string с некорректной длиной ($invalid)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с invalid bulk length

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 46: Проверка отрицательной длины bulk string

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить bulk string с отрицательной длиной ($-1)
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Сервер обрабатывает или возвращает ошибку

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 47: Проверка неполных данных bulk string

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить bulk string с обещанной длиной, но неполными данными
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с unexpected EOF

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 48: Проверка некорректного завершения bulk string

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить bulk string без \r\n в конце
3. Прочитать ответ

**Ожидаемый результат:**
1. Соединение установлено
2. Ответ содержит "-ERR" с bulk not terminated

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 49: Проверка защиты от слишком больших сообщений

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить массив с размером превышающим MAX_ARRAY_SIZE
3. Отправить bulk string с размером превышающим MAX_BULK_STRING_SIZE
4. Прочитать ответы сервера

**Ожидаемый результат:**
1. Соединение установлено
2. Ответы содержат "-ERR" с ошибками о превышении лимитов

**Постусловие:** Закрыть соединение, остановить сервер

#### Тест-кейс 50: Проверка обработки неожиданных RESP типов на входе

**Предусловие:** Сервер запущен на случайном порту

**Шаги проверки:**
1. Подключиться к серверу через TCP
2. Отправить simple string (+OK)
3. Отправить integer (:42)
4. Отправить error (-ERR test)
5. Прочитать ответы сервера

**Ожидаемый результат:**
1. Соединение установлено
2. Все ответы содержат "-ERR" с ошибками протокола

**Постусловие:** Закрыть соединение, остановить сервер


## 4. Как запускать тесты и проверку покрытия
```
python -m pytest -q
python -m pytest -q tests/unit/test_storage.py
python -m pytest -q tests/integration/test_tcp_server.py
python -m pytest --cov=src --cov-report=term-missing

```
